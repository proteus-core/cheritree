# CHERI-TrEE: Sail implementation

This README accompanies the Sail implementation mentioned in our paper "CHERI-TrEE: Flexible enclaves on capability machines".
We first discuss the installation steps required to get the artifact to run, then proceed to discuss the file structure and how it maps to the paper, and lastly describe how one can run the unit tests mentioned in the paper.

## Installation instructions
Make sure to install Sail by consulting the README of the Sail RISCV model included with this repository.
This README can be found [here](sail-riscv/README.md).

The original README for the unaltered CHERI-RISCV Sail model can be found [here](README_SAIL_RISCV.md). 
We integrated the sail-riscv submodule into this repository, so there is no need to follow any of the steps listed in this README (i.e. you can safely ignore it).

Since our development is mostly parametric in word length, you can build either a 64- or 32-bit C emulator, by running one of the following commands:
```
make c_emulator/cheri_riscv_sim_RV64
make c_emulator/cheri_riscv_sim_RV32
```
Both of these emulators are functional, but the unit tests have been written to work with and verify the 64-bit C emulator.
The ocaml emulators can currently not be generated for our sail models, since we have only added support for the SHA256 hashing function in the C FFI, and not in ocaml.

## Structure of the implementation

Our Sail modifications can be found in the `src` folder.
The tests are situated in the `test` folder and are the subject of the next section.

Within the `src` folder, the following files contain most of the modifications:
- `cheri_enclave.sail` contains parameters describing the TCB (the size of a hash value `enclave_hash_size`, the number of entries in the enclave table `table_size`, etc.) as well as its state (`EidCounter` counts the number of enclaves that have been initialized, and `ETable` describes the current state of the enclave table, in terms of a type for table entries called `EMapping`). Additionally, various functions to perform manipulations on the TCB table (e.g. retrieving, adding and removing an entry, or marking an entry as permanent) are provided here.
- `cheri_insts.sail` contains all of the new instructions. Concretely, the `EStoreId`, `EInitCode`, `EInitData`, `EDeinit` and `IsUnique` function clauses implement the corresponding instructions for the paper. These instructions rely on a variety of new auxiliary methods we wrote, the most interesting of which are the `sweep` and `sweep2` functions (which respectively implement the sweep of registers and memory for a single capability in a register as required by `IsUnique`, and for 2 capabilities in different registers as required by `EInitData`) and the support for hashing in the `make_hash` function, which we describe below. At the end of the file, encodings for all new instructions are added. Unfortunately, these encodings cannot be used to build an assembler, as we discuss in the testing section below.
- `cheri_types.sail` contains a few new exceptions (`CapEx_LinearityViolation`, `CapEx_TCBAttestViolation`) to account for new things that can go wrong in the presence of enclaves.

Lastly, to support hashing we had to add support for an external SHA256-function to Sail, since the language itself lacks such functionality.
The SHA implementation as well as some FFI wrappers to make its C code interoperate with Sail can be found in the `sha_support` folder.
Concretely, the file `shadapter.h` provides the `SHA256_reset`, `SHA256_append` and `SHA256_finish` functions that are callable from within Sail. 
They respectively allow creating a new bitstream for a hash, appending data to the current bitstream, and getting the result out.
The Makefile for Sail has been appropriately adapted to compile the SHA implementation along with the rest of the code, and to make its interface callable from within Sail (more specifically, from within the `make_hash` function in `cheri_insts.sail`, which is invoked by the `EInitData` instruction).

## Running the unit tests

### Running the unit tests yourself
The ocaml/C emulators generated by Sail expect a valid ELF file as input.
Since the tests are written in assembly and Sail does not currently generate its own assembler, we generate the required ELF input files through the Clang compiler's assembler. 
Since the unit tests use the novel enclaved execution instructions (`EInitCode/Data`, `EStoreId`, ...), running the tests requires support for assembling these instructions.
Therefore, we altered the CHERI-LLVM codebase, to introduce support for enclaved execution instructions to the LLVM assembler. 

You can obtain the correct, altered LLVM binary by checking out commit `de58a2a25c32471b4b3c2aec77fee624e24120cd` from [the CHERI-LLVM repository](https://github.com/CTSRD-CHERI/llvm-project.git) and applying the [diff file](llvm-diff.txt) which we included in this artifact to it.
Follow the instructions in the CHERI-LLVM repository to obtain the altered LLVM binary.

Open up a terminal and set the `CLANG` environment variable by executing the following:
```
export CLANG=<path-to-altered-llvm-binary>
```

Lastly, navigate to the `test` folder, and run the script for the unit tests: 
```./run_unit_tests.sh```
This will output for each test whether it succeeded (ok) or failed (fail), as well as the total number of tests that succeeded, out of the total number of tests that were run.

### Structure and contents of the unit tests
The unit tests that are run on the Sail model are a superset of those run on the Proteus implementation; tests with names starting in `prot-` were adapted from the Proteus unit tests, potentially with minor alteration because Proteus is a 32-bit platform and because the memory layout of the tests on both platforms differs slightly.
Each test is written in assembly (hence the `.S` extension), and linked with the `setup_macros.h`,  `riscv_test.h` and `proteus_macros.h` header files with set-up and macro definitions.
For example, the `RVTEST_RV32U`, `RVTEST_CODE_BEGIN/END`, `RVTEST_DATA_BEGIN/END`  macros that are invoked in each test are defined in `riscv_test.h` and serve to correctly initialize registers, interrupt handler and memory of the emulated RISC-V machine before execution of the actual test case starts, and to clearly define the code and data regions of each test.

A short description of each test's behavior now follows (test-everything is the more expansive scenario test we mentioned in the paper, the other tests are smaller unit tests with a few test cases each): 

Test Name &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | Description 
--- | ---
prot-EInitCode | Execute `EInitCode` for 2 different enclaves
prot-EInitData | Fully initialize an enclave
prot-EStoreId | Fully initialize an enclave and check that its hash is correct. The hash is precalculated. 
test-EDeinit | Fully initialize and deinitialize an enclave, and check that it is gone.
test-EInitCode | Execute `EInitCode` for a single enclave
test-EInitData | Check a few incorrect enclave initializations that should fail.
test-EStoreId | Fully initialize an enclave and check that its hash is correct. Slightly fancier than the Proteus test; hash calculation happens in the `enclave_id.py` file, which parses the test's ELF, calculates the hash of the code section and overwrites the `expected_hash` region in the test's ELF. The resulting ELF is called `test-EStoreId-Out.elf` in this case. Hash calculation happens automatically when the tests are run, so that we can reuse this script in other tests.
test-everything | More complicated scenario test involving a caller and a callee, with one-way attestation, i.e., the caller attests the identity of the callee. Concretely, the control flow of the example is as follows (party involved between brackets): `initcode -> getpubkey (caller) -> loadkeys (callee) -> sendnonce (caller) -> signnonce (callee) -> verifynonce (caller)`. Reuses the aforementioned `enclave_id.py` script to calculate and store the expected enclave hashes.
test-IsUnique | Test correctness of the memory sweep instruction `IsUnique`
test-sweep | Similar tests to the previous `IsUnique` tests, but now for the `EInitData`-induced memory sweep.
